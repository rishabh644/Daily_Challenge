int mylongestPalindromeSubseq(string s,int i,int j,vector<vector<int>>&dp)
{
    if(dp[i][j]!=-1)
    return dp[i][j];

    if(i>j)
    return 0;

    if(i==j)
    return 1;



    if(s[i]==s[j])
    dp[i][j]=mylongestPalindromeSubseq(s,i+1,j-1,dp)+2;
    else
    dp[i][j]=max(mylongestPalindromeSubseq(s,i+1,j,dp),mylongestPalindromeSubseq(s,i,j-1,dp));

    return dp[i][j];

}

class Solution {
public:
    int longestPalindromeSubseq(string s) {

    int n=s.size();

    vector<vector<int>>dp(n,vector<int>(n,-1));

    int i,j;

    return mylongestPalindromeSubseq(s,0,n-1,dp);


    }
};

/////////***********************///////////


int longestPalindromeSubseq(string s) {
   int n=s.size();

   vector<vector<int>>dp(n,vector<int>(n,0));

   // Base case: every single character is a palindrome of length 1


   for(int i=0;i<n;i++){

     dp[i][i]=1;

  }

  // Fill the table

  for(int len=2;len<=n;len++)
  {

    for(int i=0;i<=n-len;i++){
      int j=i+len-1;

      if(s[i]==s[j])
      {dp[i][j]=dp[i+1][j-1]+2;}
      else{

      dp[i][j]=max(dp[i+1][j],dp[i][j-1]);

         }


                             }



  }


  return dp[0][n-1];

}